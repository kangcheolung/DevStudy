# 응용 계층 - HTTP의 기초

# DNS와 URI/URL

## 도메인 네임과 DNS

네트워크 상의 호스트를 식별하기 위해 기본적으로 사용되는 정보는 IP 주소입니다. 하지만 오로지 IP 주소만을 사용하기에는 번거롭습니다. IP 주소는 특정 호스트의 특징을 나타내기 어렵고, 더욱이 호스트의 IP 주소는 언제든 바뀔 수 있기 때문입니다. 그래서 사용하는 것이 **도메인 네임**입니다. 도미인 네임은 ‘www.example.com’, ‘developers.naver.com’와 같은 문자열 형태의 호스트 특정 정보로, 호스트의 IP 주소와 대응합니다. 

도메인 네임과 그에 대응하는 IP 주소는 **네임 서버**라고 불리는 특별한 서버에서 관리됩니다. 도메인 네임을 관리하는 네임 서버는 **DNS 서버**라고도 부릅니다. 

### 루트 도메인과 최상위 도메인(TLD)

도메인 네임과 관련해서 알아야 할 내용은 크게 2가지로, 하나는 도메인 네임의 계층적 구조이고, 다른 하나는 도메인 네임을 관리하는 네임 서버의 계층적 구조입니다.

하나의 도메인 네임은 점(.)을 기준으로 계층적으로 분류되어 있습니다. 최상단에는 루트 도메인이 있고, 그 다음 단계에는 최상위 도메인(TLD)가 있습니다. 최상위 도메인에는 대표적으로 ‘com, net, org, kr(대한민국), jp(일본)’등이 있습니다. 예를 들어 ‘www.example.com’에서 최상위 도메인은 ‘com’입니다. 실은 도메인 네임의 마지막 부분에 점(.)으로 표현되는 루트 도메인도 도메인 네임의 일부분입니다. 하지만 일반적으로 도메인 네임을 표기할 때 루트 도메인은 생략하는 경우가 많습니다. 

뒤이어 최상위 도메인의 하부 도메인을 2단계 도메인이라 부르고, 2단계 도메인 하부의 도메인을 3단계 도메인이라 부릅니다. 일반적으로 3~5단계 정도로 구성됩니다. 또한  ‘www.example.com’처럼 도메인 네임을 모두 포함하는 도메인 네임을 **전체 주소 도메인 네임**이라고 하며, 이 FQDN을 알면 호스트를 식별할 수 있습니다. 

```jsx
www.example.com.

www: 3단계 도메인
example: 2단계 도메인
com: 최상위 도메인
.: 루트 도메인 
```

**도메인 네임 시스템(DNS)**: 네임서버는 분산되어 관리됩니다. 이렇게 계층적으로 분산되어 있는 도메인 네임에 대한 관리 체계를 도메인 네임 시스템이라고 부릅니다. DNS는 호스트가 이러한 DNS를 이용할 수 있도록 하는 애플리케이션 계층 프로토콜을 의미하기도 합니다. 

그럼 도메인 네임이 이처럼 계층적으로 분산되어 있는 네임 서버를 바탕으로 어떻게 리졸빙되는지 알아보면 호스트는 가장 먼저 로컬 네임 서버에게 도메인 네임을 질의하게 됩니다. **로컬 네임 서버**는 클라이언트랑 맞닿아 있는 네임 서버로, 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버입니다. 

클라이언트가 로컬 네임 서버를 찾을 수 있으려면 로컬 네임 서버의 주소를 알고 있어야합니다. 그래서 많은 경우 ISP가 로컬 네임 서버의 주소를 자동으로 할당해줍니다. 다만, ISP에서 할당해 주는 로컬 네임 서버 주소가 아닌, 공개 DNS 서버를 이용할 수도 있습니다. 

로컬 네임 서버가 FQND에 대응하는 IP 주소를 알고 있다면 클라이언트에게 즉시 해당 IP 주소를 반환합니다. 하지만 만일 로컬 네임 서버가 IP 주소를 모른다면 로컬 네임 서버는 FQDN에 대응하는 IP 주소를 알아낼 때까지 도메인 네임의 루트 도메인의 서버, 최상위 도메인의 서버, 그 하위의 네임서버 등에 걸쳐 질의하게 됩니다. 그렇게 최종적으로 클라이언트가 원하는 IP 주소를 반환받으면 해당 주소를 클라이언트에게 전달하게 됩니다. 

### DNS 캐시

참고로, 이처럼 질의 과정이 너무 많이 반복되면 네트워크 내 트래픽이 많아지고, 리졸빙에 지나치게 오랜 시간이 걸리기 때문에 실제로는 네임 서버들이 기존의 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 활용하는 경우가 많습니다. 이를 DNS 캐시라고 합니다. 

DNS 캐시를 활용하면 보다 적은 트래픽으로, 보다 짧은 시간 안에 원하는 IP 주소를 얻어낼 수 있기 때문에 클라이언트가 자주 접속하는 웹사이트와 같이 자주 질의되는 도메인 네임의 경우의 대부분이 로컬 네임 서버 선에서 캐시되어 있습니다. 

## 자원과 URI/URL

- 자원: 네트워크 상의 메세지를 통해 주고 받는 최종 대상을 의미합니다.
- URI/URN/URL: URI는 이러한 웹 상에서의 자원을 식별하기 위한 정보를 의미합니다. URI로 자원을 식별할 때는 ‘이름’을 기반으로 식별하기도 하고, ‘위치’를 기반으로 식별하기도 합니다. 이때 이름으로 자원을 식별하는 방식을 URN이라고 하고, 위치로 자원을 식별하는 방식을 URL이라고 합니다.

URL에 대해서 더 자세히 살펴보면 구조를 이해하는 것이 중요합니다.이는 어떠한 형식으로 위치에 따라 자원을 식별하는지에 대해 이해하는 것과 같습니다. 일반적인 URL 구조를 보겠습니다. 

```jsx
foo://www.example.com:8042/over/there?name=ferret#nose

scheme: foo
authority: www.example.com:8042
path: /over/there
query: ?name=ferret
fragment: #nose
```

### scheme

scheme는 자원에 접근하는 방법을 나타냅니다. scheme에서 명시할 수 있는 값은 매우 다양하지만, 일반적으로는 사용할 프로토콜이 명시됩니다. 가령 scheme가 ‘[http://](http://일)’일 경우 HTTP를 사용하여 자원에 접근함을 나타내고, https:// 일 경우 HTTPS를 사용하여 자원에 접근함을 나타냅니다 .

### authority

authority는 호스트를 특정할 수 있는 IP 주소나 도메인 네임이 명시됩니다. 콜론(:) 뒤에 포트 번호를 명시할 수 있습니다. 

### path

path에는 자원이 위치하고 있는 경로를 명시됩니다. 슬래시(/)를 기준으로 계층적으로 표현되며, 최상위 경로 또한 슬래시로 표현됩니다. 

### query

query는 URL에 대한 매개변수 역할을 하는 문자열입니다. 쿼리 문자열, 쿼리 파라미터 등으로 불립니다. 이는 ‘scheme, authority, path’만으로 표현하기 어려운 추가 정보와도 같습니다. 

### fragment

fragment는 자원의 일부분, 자원의 한 조각을 가리키기 위한 정보입니다. 일반적으로 HTML파일과 같은 자원에서 특정 부분을 가르키는 데 사용됩니다. 

---

# HTTP 특징과 메세지 구조

## HTTP의 특징

HTTP에는 4가지 중요한 특징이 있다. 

1. HTTP는 요청과 응답을 기반으로 동작한다. 
2. HTTP는 미디어 독립적이다. 
3. HTTP는 상태를 유지하지 않는다(스테이스리스 프로토콜)
4. HTTP는 지속 연결을 지원한다. 

### 요청 응답 기반 프로토콜

HTTP는 기본적으로 요청 메세지를 보내는 클라이언트와 이에 대한 응답 메세지를 보내는 서버가 서로 HTTP 요청 메세지와 HTTP 응답 메세지를 주고 받는구조로 작동합니다. 

### 미디어 독립적 프로토콜

애플리케이션의 다양한 데이터를 네트워크를 통해 송수신한다는 목적에 걸맞게 다양한 종류의 자원을 주고받을 수 있습니다. HTTP에서 메세지로 주고받는 자원의 종류는 미디어 타입이라고 부릅니다. 즉, HTTP는 주고받을 미디어 타입에 특별한 제한을 두지 않고, 독립적으로 작동 가능한 미디어 독립적인 프로토콜이라고 할 수 있습니다. 

### 스테이트리스 프로토콜

HTTP는 상태를 유지하지 않는 stateless 프로토콜입니다. 즉, 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억하지 않습니다. 그렇기 때문에 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주합니다. 

- HTTP가 상태를 유지하지 않는 이유
    
    HTTP 서버가 지켜야할 중요한 설계 목표에는 확장성과 견고성이 있습니다. 서버가 상태를 유지하지 않고 모든 요청을 독립적인 요청으로 처리하면 특정 클라이언트가 특정 서버에 종속되지 않습니다. 따라서 서버의 추가나 대체가 쉬워집니다. 즉, 상태를 유지 하지 않는 스테이트리스한 특성은 필요할 경우 언제든 쉽게 서버를 추가할 수 있어 확장성을 높이고, 서버 중 하나에 문제가 생기더라도 쉽게 다른 서버로 대체할 수 있어 견고성을 높일 수 있습니다. 
    

### 지속 연결 프로토콜

HTTP에는 버전이 있습니다. 오늘날 많이 사용되는 버전 중 하나인 HTTP 1.1과 2.0은 TCP를 기반으로 동작합니다. 이러한 최근 대주적으로 사용되고 있는 버전에서는 **지속 연결**이라는 기술을 제공합니다. 다른 표현으로는 **킵 얼라이브**라고도 부릅니다. 이는 하나의 TCP 연결 상에서 여러 개의 요청-응답을 주고받을 수 있는 기술을 말합니다. 지속 연결을 통해 비지속 연결보다 빠른 속도로 여러 HTTP의 요청과 응답을 처리할 수 있습니다. 

## HTTP 메세지 구조

HTTP 메세지는 기본적으로 시작 라인과 필드 라인, 그리고 메세지 부문으로 이루어져있습니다. 필드라인은 여러 개가 존재할 수 있고, 메세지 본문은 없을 수 있습니다. 메세지 본문에는 HTTP를 통해 주고 받는 자원이 명시됩니다. 

HTTP는 요청 응답 기반 프로토콜로, HTTP 요청 메세지와 HTTP 응답 메세지가 있습니다. 이때 시작 라인으로 HTTP 요청  메세지인지 응답 메세지인지를 구분할 수 있습니다. 시작 라인은 HTTP 메세지가 요청 메세지면 요청 라인이 되고, 응답 메세지일 경우 상태 라인이 됩니다. 

요청 라인과 상태 라인을 구성하는 필드의 이름이 각기 다른 것을 볼 수 있습니다. 이 중 요청 라인의 메서드와 상태 라인의 상태 코드 및 이유 구문이 가장 중요한 정보입니다. 

 

| 구분 | 필드 이름 | 설명 |
| --- | --- | --- |
| 요청 라인  | 메서드(method) | 클라이언트가 서버의 자원에 대해 수행할 작업의 종류를 나타냅니다.  |
| 상태 라인 | 상태 코드  | 요청에 대한 결과를 나타내는 3자리 정수를 나타냅니다.  |
| 상태 라인 | 이유 구문 | 상태 코드에 대한 문자열 형태의 설명입니다.  |

```jsx
HTTP/1.1 200 OK

HTTP/1.1 404 Not Found
```

# HTTP 메서드와 상태 코드

## HTTP 메서드

중요 메서드는 GET, HEAD, POST, PUT PATCH, DELETE 입니다. 

| HTTP 메서드 | 설명 |
| --- | --- |
| GET | 자원을 습득하기 위한 메서드 |
| HEAD | GET과 동일하나, 헤더만을 응답받는 메서드 |
| POST | 서버로 하여금 특정 작업을 처리하게끔 하는 메서드  |
| PUT | 자원을 대체하기 위한 메서드  |
| PATCH | 자원에 대한 부분적 수정을 위한 메서드  |
| DELETE | 자원을 삭제하기 위한 메서드  |

### GET/HEAD

GET은 가장 흔히 사용되는 메서드 중 하나로, 자원을 조회하는 용도의 메서드입니다. HEAD 메서드는 응답 메세지에 메세지 본문이 포함되지 않다는 점을 제외하면 사실상 GET 메서드와 동일합니다. 

### POST

POST는 서버로 하여금 특정 작업을 처리하도록 요청하는 용도로 사용되는 메서드입니다. 많은 경우 ‘클라이언트가 서버에 새로운 자원을 생성하고자 할 때’ 사용됩니다. 

### PUT/PATCH

PUT 메서드와 PATCH 메서드와 다른 점은 PUT 메서드는 ‘덮여쓰기’를 요청하는 메서드인 반면에 PATCH 메서드는 ‘부분적 수정’을 요청하는 메서드입니다. 

### DELETE

DELETE 메서드는 특정 자원의 삭제를 요청할 때 사용되는 메서드입니다. 

## HTTP 상태 코드

HTTP 상태 코드는 요청의 결과를 나타내는 3자리의 정수입니다. 

| 상태 코드 | 설명 |
| --- | --- |
| 100번대 | 정보성 상태 코드 |
| 200번대 | 성공 상태 코드 |
| 300번대 | 리다이렉션 상태 코드 |
| 400번대 | 클라이언트 에러 상태 코드 |
| 500번대 | 서버 에러 상태 코드  |

### 200번대: 성공 상태 코드

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 200 | OK | 요청이 성공했음 |
| 201 | Created | 요청이 성공했으며, 새로운 자원이 생성되었음 |
| 202 | Accepted | 요청을 잘 받았으나, 아직 요청할 작업을 끝내지 않았음 |
| 204 | No Content | 요청을 성공했으나, 메세지 본문으로 표시할 데이터가 없음 |

### 300번대: 리다이렉션 상태 코드

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 301 | Moved Permanently | 영구적 리다이렉션 - 재요청 메서드가 변경될 수 있음 |
| 308 | Permanently Redirect | 영구적 리다이렉션 - 재요청 메서드가 변경되지 않음  |
| 302 | Found | 일시적 리다이렉션 - 재요청 메서드가 변경될 수 있음 |
| 303 | See Other | 일시적 리다이렉션 - 재요청 메서드가 GET으로 변경된 |
| 307 | Temporary Redirect | 일시적 리다이렉션 - 재요청 메서드가 변경되지 않음  |
| 304 | Not Modified | 캐시 - 자원이 변경되지 않음  |

**영구적 리다이렉션**은 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정되는 것을 말합니다.  자원의 위치가 영구적으로 변경되었음을 시사하므로, 기존 URL에 요청 메세지를 보내면 항상 새로운 URL로 리다이렉트됩니다. 

일시적 리다이렉션은 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 주로 사용됩니다. 만약 어떤 URL이 일시적인 리다이렉션 관련 상태 코드를 응답받았다면, 영구적인 리다이렉션과 달리 여전히 요청을 보낸 기존의 URL을 기억해야합니다. 

### 400번대: 클라이언트 에러 상태 코드

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 400 | Bad Request | 요청 메세지의 내용이나 형식 자체에 문제가 있음 |
| 401 | Unauthorized | 요청한 자원에 대한 유효한 인증이 없음 |
| 403 | Forbidden | 요청이 서버에 의해 거부됨
ex) 자원에 대한 접근 권한이 충분하지 않음  |
| 404 | Not Found | 요청 받은 자원을 찾을 수 없음 |
| 405 | Method Not Allowed | 요청한 메서드를 지원하지 않음  |

401과 403을 혼동하지 않도록 주의해야합니다. 401은 인증을 요구하는 상태 코드이고, 403은 권한(인가)를 요구하는 상태 코드입니다. 인증이란 ‘자신이 누구인지를 증명하는 작업’을 의미하고, 권한이란 ‘인증된 주체에게 허용된 작업’을 의미합니다. 

예를 들어 로그인된 모든 유저는 인증된 유저라고 할 수 있지만(401), 모든 유저가 관리자 페이지에 들어갈 수 없는 것 처럼 인증이 되었더라도 권한이 충분하지 않을 수 있습니다(403). 

### 500번대: 서버 에러 상태 코드

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 500 | Internet Server Error | 요청을 처리할 수 없음 |
| 502 | Bad Gateway | 중간 서버의 통신 오류  |

# HTTP 주요 헤더

## 요청 메세지에서 주로 활용되는 HTTP 헤더

### Host

요청을 보낼 호스트가 명시되는 헤더입니다. 도메인 네임이나 IP 주소로 표현되며, 포트 번호가 포함될 수도 있습니다. 

### User - Agent

개발에서 유용하게 사용되는 대표적인 HTTP 요청 헤더입니다. 본래 유저 에이전트라는 용어는 HTTP 요청을 시작하는 클라이언트 측의 프로그램을 말하며, 이러한 프로그램에는 웹 브라우저가 대표적입니다. 유저 에이전트는 말 그대로, User - Agent 헤더에는 요청 메세지를 보낸 클라이언트의 프로그램과 관련된 정보가 명시됩니다. 

### Referer

Referer는 User-Agent와 마친가지로 개발에 유용하게 사용될 수 있는 헤더입니다. Referer 헤더는 클라이언트가 요청을 보낼 때 머무르던 URL이 명시되며, 이를 통해 클라이언트의 유입 경로를 파악할 수 있습니다. 

## 응답 메세지에서 주로 활용되는 HTTP 헤더

### Server

HTTP 응답 메세지를 보내는 서버 호스트와 관련된 정보가 명시됩니다. 

### Allow

Allow 헤더는 처리 가능한 HTTP 헤더 목록을 알리기 위해 사용됩니다. 상태 코드 405는 ‘수신을 요청한 메서드를 지원하지 않음’의 상태 코드였는데요. Allow 헤더는 다음과 같은 405 상태 코드를 응답할 때 함께 사용할 수 있다. 

### Location

Location 헤더는 클라이언트에게 자원의 위치를 알려 주기 위해 사용됩니다. 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용됩니다. 

 

## 요청과 응답 메세지  모두에서 활용되는 HTTP 헤더

### Date

Date 헤더는 이름에서 유추하듯이, 메세지가 생성된 날짜와 시각에 관련된 정보를 담는 헤더입니다. 

### Content-Length

Content-Length 헤더는 메세지 본문의 바이트 단위 크기를 표현하기 위해 사용됩니다. 

### Content-Type, Content-Language, Content-Encoding

이 3개는 표현 헤더라고 부릅니다. 이중 Content-Type은 메세지 본문에서 사용된 미디어 타입을 의미합니다. 

Content-Language 헤더는 메세지 본문에 어떤 자연어가 사용되었는지를 나타냅니다. Content-Language 헤더의 첫 번째 서브 태그에는 ‘특정 언어’를 나타내는 언어 코드가 명시되고, 두 번째 서브 태그에는 ‘특정 국가’를 나타내는 국가 코드가 명시됩니다. 

Content-Encoding 헤더에는 메세지 본문을 압축하거나 변환한 방식이 명시됩니다. 어떤 방식으로 메세지 본문이 압축/변환되었는지를 알아야 수신지 측에서 압축을 해제하고 재변환할 수 있을 것입니다.