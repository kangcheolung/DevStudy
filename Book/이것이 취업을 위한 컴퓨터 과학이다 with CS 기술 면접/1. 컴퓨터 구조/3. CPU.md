# CPU

# 레지스터

레지스터는 CPU 안에 있는 작은 임시 저장장치이다. CPU 안에는 다양한 레지스터들이 있고, 각기 다른 이름과 역할이 있다. 

## 프로그램 카운터

- 프로그램 카운터는 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장한다.
- 프로그램 카운터를 명령어 포인터라고 부르는 CPU도 있다.
- 일반적으로 프로그램 카운터는 1씩 증가하는데, 이는 곧 다음으로 읽어 들일 메모리 주소가 1씩 증가하는 것과 같다.
- 프로그래밍 언어의 조건문이나 리턴문 같이 프로그램의 흐름이 순차적이지 않을 때는 프로그램 카운터 값이 임의의 위치로 변경된다.

## 명령어 레지스터

- 명령어 레지스터는 메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터
- CPU 내의 제어장치는 명령어 레지스터 속의 명령어를 해석한 뒤 ALU로 하여금 연산하도록 시키거나 다른 부품으로 제어 신호를 보내 해당 부품을 작동시킨다.

## 범용 레지스터

- 범용 레지스터는 다양하고 일반적인 상황에서 자유롭게 사용 할 수 있는 레지스터이다.
- 데이터와 명령어, 주소 모두를 저장 가능하다.
- 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있다.

## 플래그 레지스터

- 플래그 레지스터는 연산의 결과 혹은 CPU 상태에 대한 부가 정보인 플래그 값을 저장하는 레지스터이다.
- 플래그는 CPU가 명령어를 처리하는 과정에서 반드시 참조해야할 상태의 정보를 의미하는 비트이다.

| 종류 | 설명 |
| --- | --- |
| 부호 플래그 | 연산 결과의 부호 |
| 제로 플래그 | 연산 결과가 0인지의 여부 |
| 캐리 플래그 | 연산결과에 올림수나 빌림수가 발생했는지의 여부 |
| 오버플로우 플래그 | 오버플로우가 발생했는지의 여부 |
| 인터럽트 플래그 | 인터럽트가 가능한지의 여부 |
| 슈퍼바이저 플래그 | 커널모드로 실행중인지, 사용자 모드로 실행중인지 여부 |

## 스택 포인터

- 스택포인터는 메모리 내 스택 영역의 최상단 스책 데이터의 위치를 가리키는 특별한 레지스터이다.

---

# 인터럽트

CPU의 작업을 방해하는 신호를 인터럽트라고 한다. 인터럽트는 크게 동기 인터럽트와 비동기 인터럽트로 나뉜다. 

- 동기 인터럽트(예외): CPU가 예외적인 상황을 마주쳤을 때 발생하는 인터럽트로 예외라고도 부른다.
- 비동기 인터럽트(하드웨어 인터럽트): 주로 입촐력 장치에 의해 발생하는 인터럽트이다. 비동기 인터럽트는 하드웨어 인터럽트라고도 부른다.

# 하드웨어 인터럽트(비동기 인터럽트)

CPU는 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.  예를 들어 일반적으로 입출력장치의 속도는 CPU에 비해 현저히 느리다. 그래서 CPU는 입출력 작업의 결과를 바로 볼 수 없다. 만약 하드웨어 인터럽트를 사용하지 않으면 CPU는 프린터가 언제 프린트 될지 모르기에 주기적으로 프린터의 완료 여부를 확인해야한다. 이렇듯 하드웨어 인터럽트는 입출력 완료 여부를 확인하기 위한 CPU 사이클 낭비를 최소화하고, CPU가 다른 일을 수행 할 수 있는 시간을 벌어 줌으로써 효율적으로 명령어를 처리 할 수 있도록 돕는다. 

**CPU가 하드웨어 인터럽트를 처리하는 순서** 

1. 입출력 장치는 CPU에게 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들 일 수 있는지 여부를 확인한다. 
4. 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업을 백업한다. 
5. CPU는 **인터럽트 백터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다. 
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해둔 작업을 복구하여 실행을 재개한다. 

인터럽트와 관련해 알아야할 용어는 인터럽트 요청 신호, 인터럽트 플래그, 인터럽트 백터, 인터럽트 서비스 루틴이다. 

## 인터럽트 요청 신호

- 인터럽트는 CPU의 정상적인 흐름을 끊는 행위이므로 인터럽트 하기 전에 CPU 인터럽트의 가능 여부를 확인해야 한다. 이를 위한 신호를 인터럽트 요청 신호라고 한다.

## 인터럽트 플래그

- 인터럽트 플래그는 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그이다. 만약 인터럽트 플래그가 불가능으로 설정되어 있다면 CPU는 인터럽트 요청이 오더라도 해당 요청을 무시한다.
- 정전, 하드웨어 고장과 같은 가장 먼저 처리해야하는 인터럽트는 인터럽트 플래그가 불가능으로 설정되어 있더라도 무시할 수 없는 인터럽트 요청이다. 즉 하드웨어 인터럽트는 인터럽트 플래그로 막을 수 있는 인터럽트와 막을 수 없는 인터럽트가 있다.

## 인터럽트 서비스 루틴

- 인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 프로그램으로, 인터럽트 핸들러라고도 부른다.
- 인터럽트 서비스 루틴은 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다.
- 인터럽트 요청을 받기 직전까지 CPU가 수행하고 있었던 일은 인터럽트 서비스 루틴이 끝나면 되돌아와서 마저 수행되어야 하므로 지금까지의 작업들을 메모리 내의 스택에 백업한다.

## 인터럽트 백터

- 인터럽트 백터는 각기 다른 인터럽트 서비스 루틴들을 식별하기 위한 정보이다.
- 인터럽트 백터가 인터럽트 서비스 루틴의 시작 주소를 포함하고 있기 때문에 CPU는 인터럽트 백터를 통해 처음부터 특정 인터럽트 서비스 루틴을 실행할 수 있다.

# 예외(동기 인터럽트)

예외의 종류에는 폴트, 트랩, 중단, 소프트웨어 인터럽트 등이 있다. 

- 폴트: 예외를 처리한 직후에 예외가 발생한 명령어부터 실행을 재개하는 예외이다.
- 트립: 예외를 처리한 직후에 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외이다.
- 중단: CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외이다.
- 소프트웨어 인터럽트: 시스템 콜이 발생했을 때 발생하는 예외

---

# CPU 성능 향상을 위한 설계

## CPU 클럭 속도

- 클럭은 컴퓨터의 부품을 일사분란하게 움직일 수 있게 하는 시간 단위이다.
- 클럭 속도는 헤르츠(Hz) 단위로 측정되는데, 이는 클럭이 1초에 몇 번 반복되는지를 나타낸다. 예를 들어 1초에 100번 반복되는 CPU가 있다면, 이 CPU의 클럭 속도는 100Hz이다.
- 클럭 속도는 CPU의 속도 단위로 간주되기도 한다. 하지만 클럭 속도를 필요 이상으로 높이면 컴퓨터의 발열이 심해질 수 있기 때문에 클럭 속도를 높이는 것만으로 CPU 성능을 높이는 데에는 한계가 있다.

## 멀티코어와 멀티스레드

코어: CPU 내에서 명령어를 읽어 들이고, 실행하는 부품을 의미한다. 

여러개의 코어를 포함하고 있는 CPU를 멀티코어 CPU, 혹은 멀티코어 프로세서라고 한다. 

## 스레드

하드웨어 스레드: 하나의 코어가 동시에 처리하는 명령어의 단위 

- 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 프로세서, 멀티스레드 CPU라고도 한다.
- 논리 프로세서라고 부르기도한다.

소프트웨어 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위 

## 병렬성과 동시성

병렬성: 작업을 물리적으로 동시에 처리하는 성절

동시성: 동시에 작업을 처리하는 것처럼 보이는 성질

하드웨어 스레드는 병렬성을 구현하기 위한 물리적인 실행 단위에 가깝다. 

---

# 파이프라이닝을 통한 명령어 병렬 처리

## 명령어 병렬 처리 기법

명령어 병렬 처리 기법은 여러 명령어들 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU 성능을 높이는 기법이다. 다양한 기법이 있지만, 꼭 기억해야할 명령어 병렬 처리 기법은 명령어 파이프라이닝이다. 

 ****

### 명령어 처리 과정

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장

여기서 중요한 점은 같은 단계가 겹치지 않는다면 CPU가 각각의 단계를 동시에 실행할 수 있다는 점이다. 하나의 명령어가 인출되는 동안 다른 명령어를 실행할 수 있고, 하나의 명령어가 실행되는 동안 연산 결과를 저장할 수도 있다. 이처럼 명령어들을 명령어 파이프라이닝에 넣고 동시에 처리하는 기법이 명령어 파이프라이닝이다. 

## CISC RISC

CISC: 다채로운 기능을 지원하는 복잡한 명령어들로 구성된 명령어 집합니다. 적은 수의 명령어로도 프로그램을 실행할 수 있다. 

RISC: CISC에 비해 활용 가능한 명령어의 종류가 적다. CISC와 달리 짧고 규격화된 명령어, 1클럭 내외의 명령어를 지향한다. 

이렇게 보면 RISC보다 CISC가 더 우월하다고 볼 수 있다. 하지만 CISC는 활용하는 명령어가 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기 및 실행되기까지의 시간이 일정하지 않고, 하나의 명령어 실행에 여러 클럭 주기가 필요하다. 그렇기에 CISC는 RISC에 비해 명령어 수행 시간이 길고 들쑥날쑥 하기에 파이프라이닝에 비효율적일 수 있다. 

반면 RISC는 CISC에 비해 크기가 규격화 되어 있고, 하나의 명령어가 1클럭 내외로 실행되기에 파이프라이니에 최적화 되어 있다. 

## 파이프라인 위험

### 데이터 위험

- 명령어 간의 데이터 의존성에 의해 발생한다.
- 어떤 명령어들을 동시에 처리할 수 없고, 이전 명령어들이 끝까지 실행해야만 실행할 수 있다.

### 제어 위험

- 프로그램 카운터의 갑작스러운 변화에 의해 발생한다.
- 프로그램 카운터는 기본적으로 1씩 증가하는데 JUMP, CONDITIONAL JUMP, 인터럽트 등으로 인해 프로그램 실행의 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터의 값에 갑작스러운 변화가 생기면 해석 중인 명령어들은 쓸모가 없게 된다.

### 구조적 위험

- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 부품을 사용하려고 할 때 발생한다.
- 구조적 위험은 자원 위험이라고도 부른다.