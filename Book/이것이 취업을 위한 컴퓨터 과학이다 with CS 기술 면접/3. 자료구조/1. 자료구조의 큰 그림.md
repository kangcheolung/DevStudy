# 자료구조의 큰 그림

# 시간복잡도와 공간복잡도

개발자는 프로그램을 만드는 과정에서 소스 코드를 통해 다양한 데이터를 다루고(자료구조), 그 데이터를 활용해 특정 목적을 이루기 위한 연산(알고리즘)을 구현합니다. 따라서 자료구조와 알고리즘을 고려하며 작성한 코드는 훨씬 더 품질 좋은 코드가 될 가능성이 높습니다. 

## 시간 복잡도

**“”시간복잡도””란** 입력의 크기에 따른 프로그램 실행 시간의 관계를 의미한다. 프로그램의 실행 시간과 입력의 크기는 서로 밀접한 관계가 있다. 가령 ‘서로 다른 N개의 데이터가 있을 때, 앞에서부터 차례대로 하나씩 검사하여 특정 데이터를 찾는 프로그램’이 있다고 가정해보자. 데이터가 하나(N=1)라면 프로그램의 실행 시간이 길지 않겠죠. 그러나 데이터가 100(N=100)라면 일반적으로 조금 더 오랜 시간이 소요될 것이다. 나아가 N이 10000이라면 실행 시간이 평균적으로 훨씬 더 오래 걸릴 것이다. 

이때 실행 시간은 연산의 횟수에 비례한다고 간주합니다. N이 1일때 보다 100일때 일반적으로 더 많은 연산이 필요하고, N이 100일 때보다 10000일 때 더 많은 연산이 필요할테니까요.  따라서 시간 복잡도는 입력의 크기에 따른 프로그램 실행 시간이라고 할 수도 있고, 입력의 크기에 따른 연산 횟수라고 할 수도 있다. 

이번에는 소스코드로 시간 복잡도를 이해해보겠다.

```java
for _ in range(n):   # 입력으로 주어진 값은 n; n회 반복하며  
	for _ in range(n): # 각각의 반복을 n회씩 반복하며         >> n^2(n의 제곱)번
					1+1        # 한 번씩 반복
					
for _ in range(3 * n): # 입력으로 주어진 값은 n; 3n회 반복하며
					1+1          # 한 번씩 반복                      >> 3n번
					
1+1
1+1             >>> 2번

총 (n^2 + 3n + 2)번 
```

지금까지는 예제에서 n이 값이 결정되면 코드의 연산 횟수 및 실행 시간도 함께 결정되었다. 히지만 현실 속 대부분의 프로그램은 예제처럼 입력의 크기가 결정된다고 해서 연산 횟수와 실행 시간이 무조건적으로 결정되지는 않는다. 실제로는 입력하는 n값이 같다고 하더라도 프로그램의 연산 횟수와 실행 시간이 달라질 수 있다. 

앞에서 가정했던 ‘서로 다른 N개의 데이터에서 특정 데이터를 찾는 프로그램’을 다시 생각해보자. N이 100이라면 일반적으로 , N 10000이라면 평균적으로 더 오랜 실행 시간이 소요된다고 설명했다. ‘일반적으로’, ‘평균적으로’라는 사족을 붙인 이유는 그렇지 않은 경우도 있기 때문이다. N이 10000이라도 ‘최선의 경우’, 운 좋게 단번에 원하는 데이터를 찾아낼 수도 있고, N이 100이더라도 ‘최악의 경우’, 데이터를 찾는 모든 연산을 끝내야하만 원하는 데이터를 찾아낼 수도 있다. 

그러나 상황에 따라서 동일한 입력에 대한 프로그램의 실행 시간이 들쑥 날쑥해서도 곤란해진다. 제대로 된 성능 척도로서의 기능을 할 수 없을 것이다. 그래서 시간 복잡도를 표현할때에는 대중적으로 **““빅 오 표기법””**이 사용된다. 빅 오 표기법은 함수의 **“”점근적 상한””**을 표기하는 방법이다. 시간복잡도를 표현하기 위해서는 빅 오 표기법을 사용한다면 ‘입력에 따른 실행시간의 점근적 상한’을 의미하는 것이다. 

### 점근적 상한이란?

입력하는 n이 점점 증가하여 무한대로 커진다고 생각해보자. n에 따라 일반적으로 실행 시간도 점점 증가할 것이다. 이때 실행 시간이 증가하는 데에는 한계도 있다. 이 한게를 점근적 상한이라고 한다. 입력의 크기 n에 대한 빅 오 표기법은 흔히 실행 시간의 O(상한(n))형테로 표현되며, 이는 쉽게 말해 입력하는 n이 점점 증가해 무한대로 커진다고 하더라도 실행시간이 대략 이 이상(상한)은 커지지 않을 것이라는 의미이다. 예를 들어, 시간 복잡도에서 빅 오 표기법으로 표현된 O(n^2)은 입력값 n이 증가하더라도 실행 시간의 증가율이 n^2보다 작다는 것을 의미한다. 

참고로, 빅 오 표기법 외에도 **“”빅 세타 표기법””과 “”빅 오메가 표기법””**도 있다. 시간 복잡도에서 빅 세타 표기법은 입력에 대한 ‘평균적인 실행 시간’을 의미하고, 빅 오메가 표기법은 ‘입력에 대한 실행 시간의 점근적 하한’을 의미한다. 

빅 오 표기법과 관련해 유의해야할 점이 있다. 점근적 상한을 표현할때에는 최고차항의 차수만 고려한다는 점이다. 즉, 입력값 n에 대한 실행 시간의 점근적 상한을 수식으로 표현할 때에는 최고 차항의 차수만 고려한다(입력값 n에 대한 연산 횟수에서 계수와 낮은 차수의 항을 제외시키고, 다음과 같이 최고차항의 차수만 고려).

| 필요한 연산 | 점근적 상한 | 빅 오 표기법 |
| --- | --- | --- |
| n | n | O(n) |
| 2n | n | O(n) |
| n^2 | n^2 | O(n^2) |
| n^2 + 3n +2 | n^2 | O(n^2) |

그리고 시간 복잡도는 그래프로 표현할 수 있는데 n이 충분히 클 때 가장 성능이 좋지 않은 시간 복잡도는 O(n!)이다. 그렇다면 n이 충분히 클 때 O(n^2)의 복잡도를 갖는 알고리즘과 O(1)의 복잡도를 갖는 알고리즘 중 더 성능이 좋은 알고리즘은 무엇일까? 당연히 후자이다. O(1)은 입력값이 10개, 1억개든 상관없이 항상 알고리즘의 실행 시간이 일정하다는 의미이거, O(n^2)은 n이 증가함에 따라 n의 제곱만큼 실행 시간이 증가한다는 것을 의미한다. 

## 공간 복잡도

공간 복잡도는 프로그램이 실행되었을 때 필요한 메모리 자원의 양을 의미한다. 시간 복잡도가 입력에 따른 척도라면, 공간 복잡도는 입력에 따른 메모리의 사용량의 척도라고 할 수 있다. 

공간 복잡도를 빅 오 표기법으로 표현하면 입력에 따라 필요한 메모리의 자원의 양에 대한 점근적 상한을 표현하게 된다.