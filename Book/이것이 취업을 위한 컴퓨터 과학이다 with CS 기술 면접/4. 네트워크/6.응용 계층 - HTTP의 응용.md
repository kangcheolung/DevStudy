# 응용 계층 - HTTP의 응용

# 쿠키

**쿠키**는 HTTP의 스테이트리스한 특성을 보완하기 위한 대표적인 수단으로, 서버에서 생성되어 클라이언트 측에 저장되는 <이름, 값> 쌍 형태의 데이터입니다. 이름과 값 이외에도 때로는 쿠키의 만료 기간과 같은 추가적인 속성값을도 가질 수 있습니다. 

클라이언트는 서버로부터 받은 쿠키를 주로 브라우저에 저장합니다. 그렇게 때문에 서버로부터 전달받은 쿠키는 브라우저를 통해 확인할 수 있습니다. 

서버가 클라이언트에게 쿠키를 전송할 때는 응답 메세지의 Set - Cookie 헤더가 활용되고, 클라이언트가 서버에게 쿠키를 건넬 때는 Cookie 헤더가 활용됩니다. 

```jsx
응답 메세지

Set-Cookie: 이름-값
Set-Cookie: 이름-값; 속성1
Set-Cookie: 이름-값; 속성1; 속성2
```

서버에 여러 쿠키를 전달할 때는 세미콜론(;)으로 여러 쿠키의 <이름, 값> 쌍을 구분할 수 있습니다. 여기서 유의할 점은 특정 서버로부터 쿠키를 전달 받았다면 다음부터 해당 서버에 요청을 보낼 때  전달받은 쿠키를 자동으로 전송한다는 점입니다. 즉, 어떤 서버로부터 쿠키를 전달받으면 해당 서버에 보내는 요청 메세지에는 자동으로 전달받은 쿠키가 포함됩니다. 

```jsx
요청 메세지

Cookie: 이름=값; 이름=값;
```

쿠키 데이터는 기본적으로 <이름, 값>의 쌍으로 구성되어 있지만, 앞선 예시에서 볼 수 있듯 대부분의 쿠키 데이터에는 속성값이 포함되어 있습니다. 쿠키는 domain과 path를 통해 쿠키를 전송할 도메인과 경로를 제한할 수 있습니다. 

```jsx
응답 메세제

Set-Cookie: name=minchul domain=minchul.net
Set-Cookie: name=minchul path=/lectures
```

또한 Expires로 명시된 시점이 지나거나 Max-Age로 명시된 유효기간이 지나면 해당 쿠키는 삭제되어 전달되지 않습니다. Expires는 [요일, DD-MM-YY HH:MM:SS GMT]의 형식으로 표기되는 쿠키 만료 시점을 의미하고, Max-Age는 초 단위 유효기간을 의미합니다. 

```jsx
응답 메세지

Set-Cookie: sessionID=abc123; Expries: ~~
Set-Cookie: sessionID=abc123; Max-Age: ~~
```

쿠키의 보안 속성으로 Secure과 HttpOnly라는 속성도 있습니다. Secure는 HTTP의 더 안전한 방식인 HTTPS를 통해서만 쿠키를 송수신하도록 하는 속성입니다. HttpOnly는 자바스크립트를 통한 쿠키의 접근을 제한하고, 오직 HTTP 송수신을 통해서만 쿠키에 접근하도록 하는 방식입니다. 

```jsx
응답 메세지

Set-Cookie: sessionID=abc123; Secure
Set-Cookie: sessionID=abc123; HttpOnly
```

---

# 캐시

캐시는 응답받은 자원의 사본을 임시 저장하여 불필요한 대역폭 낭비와 응답 지연을 방지하는 기술입니다.  

대부분의 캐시된 데이터는 유효기간이 설정되어 있습니다. 클라이언트가 응답받은 자원을 임시 저장하여 이용하다가 유효기간이 만료되면 다시 서버에 자원을 요청해야 합니다.

- 캐시에 유효기간이 부여되는 이유
    
    캐시에 유효기간이 부여되는 근본적인 이유는 클라이언트가 캐시를 참조하는 사이 서버의 원본 데이터가 변경되어 원본 데이터와 사본 데이터 간의 일관성이 깨질 수 있기 때문입니다. 
    
    캐시 신선도: 캐시된 사본 데이터가 서버의 원본 데이터와 얼마나 유사한지의 정도 
    

캐시의 유효기간이 만료되었더라도 캐시된 데이터가 여전히 최신 데이터라면 클라이언트는 굳이 서버로부터 같은 자원을 응답받을 필요가 없습니다. 그저 캐시의 유효기간을 연장하여 이용하면 됩니다. 

하지만 만약 서버의 원본 데이터가 변경되었다면 새로운 자원을 응답받아야 합니다. 그래서 클라이언트는 캐시된 자원의 유효기간이 만료되었을 때, 서버에게 원본 자원이 변경된 적이 있는지를 질의합니다. 이에 대한 서버의 응답에 따라 캐시된 자원의 유효기간을 연장하여 사용할지, 새로운 자원을 응답받아 사용할지를 결정하게 됩니다. 

## If-Modified-Since

### 클라이언트 입장

클라이언트가 날짜를 기반으로 원본 자원의 변경 여부를 묻는 헤더로는 If-Modified-Since 헤더가 대표적입니다. If-Modified-Since 헤더의 값으로는 다음과 같은 특정 시점이 명시되는데, 이 시점 이후로 원본 자원에 변경이 있었다면 그때만 변경된 자원을 메세지 본문으로 응답하도록 서버에게 요청하는 헤더입니다. 

### 서버 입장

서버 입장에서는 크게 3가지 중 하나의 상황을 따르게 됩니다. 

1. 서버가 요청받은 자원이 변경된 경우

서버는 상태 코드 200(OK)과 함께 새로운 자원을 반환합니다. 

1. 서버가 요청받은 자원이 변경되지 않은 경우

서버는 메세지 본문없이 상태 코드 304를 통해 클라이언트에게 ‘자원이 변경되지 않았음’을 알립니다. 이 경우 클라이언트는 캐시된 자원을 사용할 수 있습니다. 이때 서버는 상태 코드 304와 함께 Last-Modifed 헤더로 자원의 ‘마지막 변경 시점’을 알릴 수 있습니다. 

1. 서버가 요청받은 자원이 삭제된 경우

서버는 상태코드 404를 통해 요청한 ‘자원이 존재하지 않음’을 알립니다. 흔히 Etag라고도 부르는 엔터티 태그는 ‘자원의 버전’을 식별하기 위한 정보를 말합니다. 자원이 변경될 때마다 자원의 버전을 식별하는 Etag 값이 변경되고, 반대로 자원이 변경되지 않았다면 Etag 값도 변경되지 않습니다. 

따라서 서버에 특정 엔터티 값이 변경되었는지를 물음으로써 자원 변경 여부를 알 수 있습니다. 이를 위한 대표적인 HTTP 요청 헤더로는 If-None-Match 헤더가 있습니다. 

## If-None-Match

서버의 입장에서 If-None-Match 헤더를 받은 서버의 자원은 크게 3가지 중 하나의 상황을 따르게 됩니다. 

1. 서버가 요청받은 자원이 변경된 경우

서버는 상태 코드 200과 함께 새로운 자원을 반환합니다. 

1. 서버가 요청받은 자원이 변경되지 않은 경우

서버는 메세지 본문없이 상태 코드 304를 통해 클라이언트에게 ‘자원이 변경되지 않았음’을 알립니다. 이 경우 클라이언트는 캐시된 자원을 사용할 수 있습니다.

1. 서버가 요청받은 자원이 삭제된 경우

서버는 상태코드 404를 통해 요청한 ‘자원이 존재하지 않음’을 알립니다.

# 콘텐츠 협상

표현이란 ‘송수신 가능한 자원의 형태’를 의미합니다. 

### 콘텐츠 협상

같은 자원에 대해 할 수 있는 여러 표현 중 클라이언트가 가장 적합한 자원의 표현을 제공하는 기술을 콘텐츠 협상이라고 합니다. 자원에 대한 다양한 표현 중 클라이언트가 선호하는 자원의 표현을 콘텐츠 협상 헤더를 통해 서버에게 전송하면 서버는 클라이언트가 요청한 자원의 표현을 응답합니다. 

- Accept: 선호하는 미디어 타입을 나타내는 헤더
- Accept-Language: 선호하는 언어를 나타내는 헤더
- Accept-Encoding: 선호하는 인코딩 방식을 나타내는 헤더

# 보안: SSL/TSL와 HTTPS

HTTPS는 HTTP에 SSL 혹은 TSL라는 프로토콜의 동작이 추가된 프로토콜입니다. 

SSL과 TSL는 모두 인증과 암호화를 수행하는 프로토콜로, TLS는 SSL을 계승한 프로토콜입니다. 따라서 SSL과 TSL의 작동 과정은 세부적인 차이가 있을 수는 있지만 큰 틀에서 보면 유사합니다. 

HTTP에 1.1, 2.0과 같은 버전이 있는 것처럼 TLS에도 버전이 있습니다. 이중 오늘날 주로 사용되는 버전은 1.2와 1.3이고, 상대적으로 최근에 출시된 TLS 1.3의 비중이 커지고 있습니다. 따라서 TLS 1.3의 동작을 통해 HTTPS이의 동작 과정을 이해해보겠습니다. TLS 1.3 기반 HTTPS 메세지는 크게 다음과 같은 단계를 거쳐 송수신 됩니다. 

1. TCP 쓰리 웨이 핸드셰이크
2. TLS 핸드셰이크
3. 메세지 송수신

이중 우리가 알아할 TLS 핸드셰이크의 핵심 내용은 크게 2가지입니다. 하나는 TLS 핸드셰이크를 통해 암호화 통신을 위한 키를 생성/교환할 수 있다는 점이고, 하나는 인증서 송수신과 검증이 이루어질 수 있다는 점입니다. 

- 암호화 통신을 위한 키란?
    
    암호화를 수행하는 알고리즘은 암호하ㅘ 알고리즘이라고 합니다. 그리고 TLS애서 활용되는 암호화 알고리즘을 통해 평문을 암호화하거나 반대로 암호문을 복호화하라면 키라는 정보가 필요합니다. 키는 암호화 통신을 수행하는 두 호스트만 알고 있어야하는 정보로, TLS 핸드셰이크 과정에서 ClientHello 메세지, ServerHello 메세지를 주고받으며 생성/교환됩니다. 
    

### TLS 핸드셰이크 과정

처음으로 클라이언트는 ClientHello 메세지를 보냅니다. 이 메세지는 암호화된 통신을 위해 서로 맞춰봐야할 정보를 제시하는 메세지입니다. 

이때 클라이언트는 ‘사용가능한 암호화 알고리즘과 해시 함수’를 서버에 알리기 위해 ClientHello 메세지에 다음과 같은 형태의 정보를 포함하여 전송합니다. 이를 **암호 스위트**라고 합니다. 

서버는 ClientHello 메세지에 대한 응답으로 ServerHello 메세지를 전송합니다. ServerHello 메세지는 제시된 정보들을 선택하는 메세지입니다.  따라서 이 메세지에는 선택된 TLS 버전, 암호, 스위트 등의 정보키를 만들기 위해 사용할 서버의 난수 등이 포함되어 있습니다. 

TLS 핸드셰이크는 암호화 통신을 위한 키의 교환도 이루어지지만, 인증서의 송수신과 검증도 이루어질 수 있습니다. **인증서**는 ‘당신이 통신을 주고받는 상대방은 틀림없이 당신이 의도한 대상이 맞다’라는 사실을 입증하기 위한 정보입니다. 

하지만 송수신한 당사자가 ‘당신이 통신을 주고받는 상대방은 틀림없이 당신이 의도한 대상이 맞다’는 사실을 보장하면 아무런 의미가 없기에 제 3의 기관이 보장해야합니다. 그래서 인증서를 발급하고 검증하는 제3의 인증 기관(CA)가 있습니다. **CA**는 인증서의 발급과 검증, 저장 등의 역할을 수행하는 공인 기관입니다. 

그리고 인증서 및 인증서 검증과 관련된 메세지로는 Certificate 메세지와 CertificateVerify 메세지가 있습니다. Certificate 메세지는 인증서 서명값 등 앞서 제시한 인증서 내용들이 포함되어 있으며,  CertificateVerify 메세지는 인증서의 내용이 올바른지 검증하기 위한 메세지입니다. 

이렇게 서버와 클라이언트는 암호화에 사용할 키를 획득하고, 서로가 틀림없다는 사실까지 인증했으면, 마지막으로 Finished 메세지를 주고 받고, 이후부터는 TLS 핸드셰이크를 톨해 얻어낸 키를 기반으로 암호화된 메시지를 주고받게 됩니다.