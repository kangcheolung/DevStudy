# 전송 계층 - TCP와 UDP

# TCP와 UDP의 목적과 특징

네트워크 상 호스트가 실행하는 프로세스를 포트 번호를 통해 식별할 수 있다. 네트워크 패킷을 주고받는 프로세스에는 포트 번호가 할당됩니다. 

포트를 통한 프로세스 식별은 전송 계층(TCP, UDP)의 주된 목적입니다. 전송 계층의 핵심 프로토콜인 TCP와 UDP는 모두 포트를 통해 프로세스를 식별할 수 있습니다. 

16비트로 표현할 수 있는 포트 번호의 총 개수는 65536개입니다. 그리고 포트 번호는 번호의 범위에 따라 3가지 종류로 나뉩니다. 

| 포트 종류 | 포트 번호 범위 |
| --- | --- |
| 잘 알려진 포트 | 0~1023 |
| 등록된 포트 | 1024~49151 |
| 동적 포트 | 49152~65535 |

### 잘 알려진 포트

잘 알려진 포트는 이름 그대로 가장 대중적으로 사용되는 애플리케이션을 위한 포트 번호입니다. 

| 잘 알려진 포트 번호 | 설명 |
| --- | --- |
| 20,21 | FTP |
| 22 | SSH |
| 23 | TELNET |
| 53 | DNS |
| 67,68 | DHCP |
| 80 | HTTP |
| 443 | HTTPS |

### 등록된 포트

등록된 포트는 잘 알려진 포트에 비해서는 덜 범용적이지만, 흔하게 사용되는 애플리케이션 프로토콜에 할당하기 위한 포트 번호입니다. 

| 등록된 포트 번호 | 설명 |
| --- | --- |
| 1194 | OpenVPN |
| 1433 | Microsoft SQL Server DB |
| 3306 | MYSQL 데이터베이스 |
| 6379 | Redis |
| 8080 | HTTP 대체 |

### 동적포트

서설포트 또는 임시포트라고 하는 동적포트는 비교적 자유롭게 사용 가능한 포트 번호입니다. 

서버로서 동작하는 프로그램의 경우 주로 잘 알려진 포트와 등록된 포트가 할당되는 경우가 많지만, 클라이언트로서 동작하는 프로그램의 경우에는 동적 포트 번호 중에서 임의의 번호가 할당되는 경우가 많습니다. 

## (비)신뢰성과 (비)연결형 보장

TCP는 신뢰할 수 있는 프로토콜이자 연결형 프로토콜이고, UDP는 신뢰할 수 없는 프로토콜이자 비연결형 프로토콜입니다. 

TCP는 패킷을 주고받기 전에 연결 수립 과정을 거치며, 연결 수립 이후 패킷을 주고받을 때 신뢰성 보장을 위해 상태 관리, 흐름 제어, 혼잡 제어 등의 각종 기능을 제공합니다. 그리고 패킷의 송수신이 모두 끝나면 연결을 종료합니다. 반면 UDP는 연결의 수립이나 종료 단계를 거치지 않고, 신뢰성을 높이기 위한 기능들도 제공하지 않습니다. 

물론 신뢰할 수 있는 연결형 송수신에는 시간과 연산이 소요되기 때문에 일반적으로 TCP가 UDP에 비해 송수신 속도가 느립니다. 따라서 패킷의 유실 없는 송수신을 원항다면 UDP보다 TCP를 선택하는 것이 유리하고, 비교적 빠른 송수신을 원한다면 TCP보다 UDP를 선택하는 것이 유리합니다. 

TCP와 UDP의 특징은 헤더를 보면 이해할 수 있습니다. 

UDP 헤더에는 포트 번호가 명시되는 필드가 있습니다. 

- 송신지 포트: 송신 프로세스가 할당된 포트 번호 명시
- 수신지 포트: 수신 포로세스가 할당된 포트 번호 명시
- 길이 필드: 헤더를 포함한 UDP 패킷의 바이트 크기 명시
- 체크섬 필드: 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보 명시

TCP 헤더 필드 수는 UDP보다 훨씬 많습니다. TCP가 UDP와 달리 연결의 수립과 종료, 신뢰성 보장을 위한 여러 기능을 제공하기 때문입니다. UDP 헤더에 있는 모든 필드가 TCP 헤더에 포함되어 있습니다. 이중 우리가 알아야할 필드는 3가지가 있는 순서 번호 필드와 확인 응답 번호 필드, 일부 제어 비트(ACK 플래그, SYN 플래그, FIN 플래그)입니다. 

### 순서 번호

순서 번호란 TCP 패킷의 올바른 송수신 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호입니다. 순서 번호를 통해 현재 주고받는 TCP 세그먼트가 송수신하고자 하는 데이터의 몇 번째 바이트에 해당하는지 알 수 있는 셈입니다. 

### 확인 응답 번호

확인 응답 번호는 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하길 기대하는 순서 번호입니다. 일반적으로 ‘올바르게 수신한 순서 번호에 1을 더한 갑’으로 설정된다. 

### 제어 비트

제어 비트는 현재 세그먼트에 대한 부가 정보를 나타내는 정보로, 플래그 비트라고도 부릅니다. 제어 비트는 기본적으로 8비트로 구성되며, 각 자리의 비트가 각기 다른 의미를 가집니다. 

- ACK: 세그먼트의 승인을 나타내기 위한 비트
- SYN: 연결을 수립하기 위한 비트
- FIN: 연결을 종료하기 위한 비트

---

# TCP의 연결부터 종료까지

## TCP의 연결 수립

TCP의 연결 수립은 쓰리 웨이 핸드셰이크를 통해 이루어집니다. 쓰리 웨이 핸드셰이크는 쓰리 웨이라는 이름처럼 세 단계로 이루어진 TCP의 연결 수립 과정을 뜻합니다. 

### 1. [송수신 방향 A → B] SYN 세그먼트 전송

호스트 A는 SYN 비트가 1로 설정된 세그먼트를 호스트 B에게 전송합니다. 이 때 세그먼트 순서 번호에는 호스트 A의 순서 번호가 포함되어 있습니다. 

### 2. [송수신 방향 B → A] SYN + ACK 세그먼트 전송

1에 대한 호스트 B에 대한 응답입니다. 호스트 B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트를 호스트 A에게 전송합니다. 세그먼트의 순서 번호에는 호스트 B의 순서 번호와 1에서 보낸 세그먼트에 대한 확인 응답 번호가 포함되어 있습니다.

### 3. [송수신 방향 A → B] ACK 세그먼트 전송

호스트 A는 ACK 비트가 1로 설정된 세그먼트를 호스트 B에게 전송합니다. 세그먼트 순서 번호에는 호스트 A의 순서 번호와 2에서 보낸 세그먼트에 대한 확인 응답 번호가 포함되어 있습니다. 

SYN 비트는 연결을 수립하기 위한 비트입니다. TCP 연결 수립 과정에서 SYM 비트가 설정된 패킷을 처음으로 보내는 호스트가 곧 처음으로 연결 요청을 보내는 호스트입니다. 

호스트 A처럼 처음 연결을 시작하는 과정은 **액티브 오픈**이라고 하고, 반대로 호스트 B처럼 연결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정을 **패시브 오픈**이라고 합니다. 서버 - 클라이언트 관계에서 액티브 오픈은 주로 클라이언트에 의해 수행되고, 패시브 오픈은 주로 서버에서 수행됩니다. 

## TCP의 오류, 흐름, 혼잡 제어

TCP는 송수신하는 패킷의 신뢰성을 보장하기 위해 크게 3가지 기능을 제공합니다. 각각 오류 제어와 흐름 제어, 혼잡 제어입니다. 

TCP는 재전송을 기반으로 다양한 오류를 제어하고, 송수신의 흐름을 제어해 처리할 수 있을 만큼의 데이터만 주고받으며, 혼잡 제어를 통해 네트워크의 혼잡 정도에 따라 데이터의 전송량을 조절합니다. 

### 1. 재전송을 통한 오류 제어

TCP는 송수신 과정에서 잘못 전송된 세그먼트가 있을 경우, 이를 재전송하여 오류를 제어합니다. 그렇다면 TCP는 ‘언제 잘못 전송된 세그먼트가 있음’을 인지할까요? 여기에는 크게 2가지 상황이 있습니다. 하나는 중복된 ACK 세그먼트가 도착했을 때이고, 다른 하나는 타임 아웃이 발생했을 때입니다. 

타임아웃은 TCP 세그먼트를 송신하는 호스트는 모두 재전송 타이머라는 특별한 값을 유지하는데, 호스트는 세그먼트를 전송할 때마다 이 재전송 타이머를 시작합니다. 이 타이머의 카운트 다운이 끝난 상황을 **타임아웃**이라고 하며, 타임아웃이 발생 시점까지 ACK 세그먼트를 받지 못하면 세그먼트 전송 과정에 문제가 발생했다고 간주하여 세그먼트를 재전송합니다. 

### 2. 흐름 제어

TCP의 흐름 제어는 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송하는 것을 의미합니다. 즉, 흐름에저는 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능입니다. 

송신 호스트는 수신 호스트가 한 번에 처리할 수 있는 양을 윈도우 필드를 통해 알고 보내줄 수 있습니다. 이 윈도우 필드에는 한 번에 처리할 수 있는 수신 윈도우 크기가 명시됩니다. 수신 호스트는 윈도우 필드를 통해 수신 호스트에게 한 번에 처리 가능한 양을 알려 주고, 송신 호스트는 전달 받은 해당 값을 토대로 세그먼트를 전송합니다. 

### 3. 혼잡 제어

혼잡이란 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황을 의미합니다. 혼잡 제어는 혼잡을 제어하기 위한 기능입니다. 흐름 제어의 주체가 수신 호스트였다면 혼잡 제어의 주체는 송신 호스트입니다. 송신 호스트가 주체적으로 얼마나 네트워크가 혼잡한지를 판단할 수 있어야하고, 판단된 혼잡의 정도에 따라 세그먼트의 전송량을 조절할 수 있어야합니다. 

네트워크의 혼잡 가능성을 검출한 송신 호스트는 전송할 수 있는 최대 전송량을 송신하는 것이 아니라 ‘혼잡 없이 전송할 수 있을 정도의 양’만큼만 송신하게 됩니다. 이 ‘혼잡 없이 전송할 수 있을 정도의 양’을 혼잡 윈도우라고 합니다. 

혼잡 윈도우가 크면 한 번에 전송할 수 있는 세그먼트의 수가 많음을 의미하고, 반대로 혼잡 윈도우가 자그면 네트워크가 혼잡한 상황이므로 한 번에 전송할 수 있는 세그먼트의 수가 적음을 의미합니다. 

- AIMD(혼잡 제어 알고리즘)
    
    AIMD를 번역하면 ‘합으로 증가, 곱으로 감소’라는 의미입니다. AIMD는 세그먼트를 보내고, 그에 대한 응답이 오기까지 혼잡이 감지되지 않으면 혼잡 윈도우를 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘입니다. 
    
    참고로, 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간을 RRT라고 합니다. 따라서 AIMD는 ‘혼잡이 감지되지 않으면 혼잡 윈도우를 RRT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 알고리즘’이라고 정의할 수 있습니다. 
    

## TCP 종료

TCP 종료는 송수신 호스트가 각자 한 번의 FIN과 ACK를 주고 받으며 이루어집니다. 

### 1. [송수신 방향  A → B] FIN 세그먼트

호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송합니다. 

### 2. [송수신 방향 B → A] ACK 세그먼트

1에 대한 호스트 B의 응답입니다. 호스트 B는 ACK 세그먼트를 호스트 A에게 전송합니다. 

### 3. [송수신 방향 B → A] FIN 세그먼트

호스트 B는 FIN 세그먼트를 호스트 A에게 전송합니다. 

### 4. [송수신 방향 A → B] ACK 세그먼트

3에 대한 호스트 A의 응답입니다. 호스트 A는 ACK 세그먼트를 호스트 B에게 전송합니다. 

TCP 종료 과정에는 액티브 클로즈와 패시브 클로즈가 있습니다. **액티브 클로즈**는 먼저 연결을 종료하려는 호스트에 의해 수행되는 동작을 의미합니다. 반대로, **패시브 클로즈**는 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작을 말합니다. 

# TCP의 상태 관리

TCP의 상태를 유지하고 관리하는 프로토콜이라는 점에서 스테이트풀 프로토콜이라고 부릅니다. 여기서 상태란 현재 어떤 통신 과정에 있는지를 나타내는 정보를 말합니다. TCP의 상태 정보를 토대로 현재 TCP 송수신 현황을 판단할 수 있고, 디버깅의 힌트로도 활용할 수 있습니다. 

TCP의 모든 상태를 기억하기 어렵고, 다음과 같은 항목화를 통해 정리할 수 있습니다. 

1. 연결이 수립되지 않았을 때 주로 활용되는 상태
2. 연결 수립 과정에서 주로 활용되는 상태
3. 연결 종료 과정에서 주로 활용되는 상태 

1. 연결이 수립되지 않았을 때 주로 활용되는 상태

| 상태 | 설명 |
| --- | --- |
| CLOSED | 아무런 연결이 없는 상태 |
| LISTEN  | 연결 대기 상태 |
1. 연결 수립 과정에서 주로 활용되는 상태

| 상태 | 설명 |
| --- | --- |
| SYN-SENT | 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤, 그에 대한 응답으로 SYN + ACK 세그먼트를 기다리는 상태(연결 요청 전송) |
| SYN-RECEIVED | 패시브 오픈 호스트가 SYN 세그먼트를 보낸 뒤, 그에 대한 응답으로 SYN + ACK 세그먼트를 기다리는 상태(연결 요청 수신) |
| ESTABLISHED | 쓰리 웨이 핸드셰이크가 끝난 뒤 데이터를 송수신할 수 있는 상태(연결 수립) |
1. 연결 종료 과정에서 주로 활용되는 상태 

| 상태 | 설명 |
| --- | --- |
| FIN- WAIT-1 | 액티브 클로즈 호스트가 FIN 세그먼트로 연결 종료 요청을 보낸 상태 |
| CLOSED-WAIT | FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태 |
| FIN-WAIT-2 | FIN- WAIT-1 상태에서 ACK 세그먼트를 받은 상태 |
| LAST-ACK | CLOSED-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태 |
| TIME- WAIT | 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 접어드는 상태  |