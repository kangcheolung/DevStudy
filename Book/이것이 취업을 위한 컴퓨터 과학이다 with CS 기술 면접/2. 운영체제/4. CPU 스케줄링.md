# CPU 스케줄링

## CPU 스케줄링

CPU 스케줄링은 운영체제의 CPU 배분 방법이다. 그리고 CPU 알고리즘은 이러한 CPU 스케줄링의 절차를 말하며, 이 CPU 스케줄링 알고리즘을 결정하고 수행하는 운영체제의 일부분을 CPU 스케줄러라고 한다. 

## 우선순위

모든 프로세스는 CPU 자원을 필요로 하기 때문에 운영체제는 공정하고 합리적인 방법으로 CPU의 자원을 프로세스에 할당해야 한다. CPU 자원을 공정하게 배분하는 방법이란 단순히 돌아가면서 CPU를 프로세스들에 할당하는 것이 아니다. CPU 자원을 할당받을 프로세스의 우선순위가 다르기 때문이다. 
운영체제는 프로세스별 우선순위를 판단하여 PCB에 명시하고, 우선순위가 높은 프로세스에는 CPU 자원을 더 빨리, 더 많이 할당한다. 

**“CPU 활용률”이란** 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율을 의미한다. 운영체제는 높은 CPU 활용률을 유지하기 위해 기본적으로 입출력 작업이 많은 프로세스의 우선순위를 높게 유지한다. 

대부분의 프로세스들은 CPU와 입출력장체를 모두 사용해 실행과 대기 상태를 오가며 실행된다. 이떄 프로세스가 CPU를 이용하는 작업을 “**CPU 버스트”**라고 하고, 입출력장치를 기다리는 작업을 “**입출력 버스트**”라고 한다. 
그리고 프로세스 마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있는데 이에 따라 “**입출력 집중 프로세스**”와 “**CPU 집중 프로세스**”로 나뉜다.

입출력 집중 프로세스는 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무르지만, CPU 집중 프로세스는 대기 상태보다 실행 상태에 더 많이 머무르비다. 각자 주로 머무르는 상태가 다르기 때문에 모든 프로세스가 동일한 시간의 빈도로 CPU를 사용하는 것은 합리적이지 않다. 

만약 입출력 집중 프로세스와 CPU 집중 프로세스가 동시에 CPU 자원을 요구했다면 “입출력 집중 프로세스를 가능한 빨리 실행시켜 끊임없이 입출력장치를 작동시킨 다음, CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것”이 더 합리적이다. 

- 이유
    
    입출력 장치가 입출력 작업을 완료하기 전까지 입출력 집중 프로세스는  어차피 대기 상태가 될 것이므로 얼른 입출력 집중 프로세스를 먼저 처리해 버리면 그 이후에 다른 프로세스를 실행시켜 CPU 활용률을 높일 수 있다. 
    

## 스케줄링 큐

운영체제는 프로세스들에게 ‘자원을 이용하고 싶다면 줄을 서서 기다릴 것’을 요구한다. 이는 비단 CPU 자원에 국한된 이야기가 아니며, CPU를 이용하고 싶거나 메모리에 적재되고 싶은 프로세스, 대기 상태로 특정 입출력 장치를 이용하고 싶은 프로세스 모두에 해당합니다. 그리고 이 줄은 **“스케줄링 큐**”를 통해 구현된다. 

### 준비 큐와 대기 큐

- 준비 큐: 준비 큐는 CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄을 의미한다.
- 대기 큐: 대기 큐는 대기 상태에 접어든 프로세스의 PCB가 서는 줄을 의미한다.

 

## 선점형 스케줄링과 비선점형 스케줄링

### 선점형 스케줄링

**“선점형 스케줄링**”은 현재 어떤 프로세스가 CPU를 할당 받아 사용하고 있더라도 운영체제가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링을 말한다.  

- 장점: 언제든 더 급한 프로세스가 끼어들어 CPU를 사용할 수 있으므로 한 프로세스의 CPU 독점을 막고 여러 프로세스에 골고루 CPU 자원을 배분할 수 있다.
- 단점: 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

### 비선점형 스케줄링

**“비선점형 스케줄링”**은 어떤 프로세스가 CPU를 사용하고 있을 때 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 말한다. 

- 장점: 선점형 스케줄링보다 문맥 교환 횟수가 적기 때문에 상대적으로 오버헤드의 발생은 적다.
- 단점: 어떤 프로세스가 CPU를 사용 중이라면 당장 CPU를 사용해야하는 프로세스라도 무작정 기다릴 수 밖에 없다는 단점이 있다.

## CPU 스케줄링 알고리즘

### 선입 선처리 알고리즘

선입 선처리 알고리즘은 단순히 준비 큐에 산입된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU 할당하는 스케줄링 방식이다. 때때로 프로세스들이 먼저 기다리는 시간이 매우 길어질 수 있다는 부작용이 있으며, **“”호위 효과””**가 발생 할 수 있다.

- 호위 효과
    
    먼저 삽입된 프로세스의 오랜 실행 시간으로 인해 나중에 삽입된 프로세스의 실행이 지연되는 문제
    

### 최단 작업 우선 스케줄링

최단 작업 우선 스케줄링은 준비 큐에 삽입된 프로세스 중 CPU를 이용하는 시간의 길이가 가장 짧은 프로세스부터 먼저 실행하는 스케줄링 방식이다. 최단 작업 우선 스케줄링은 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 뒤에서 언급할 ‘최소 잔여 시간 우선 스케줄링’처럼 선점형으로 구현될 수도 있다. 

### 라운드 로빈 스케줄링

라운드 로빈 스케줄링은 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식으로, “타임 슬라이스”란 프로세스가 CPU를 사용하도록 정해진 시간을 의미한다. 즉, 라운드 로빈 스케줄링은 큐에 삽입된 프로세스들이 삽입된 순서대로 CPU를 이용하되, 정해진 타임 슬라이스만큼만 CPU를 이용하는 선점형 스케줄링이다. 

### 최소 잔여 시간 우선 스케줄링

최소 잔여 시간 우선 스케줄링은 최단 작업 우선 스케줄링과 라운드 로빈 스케줄링을 합친 스케줄링 방식이다. 프로세스로 하여금 정해진 타임 슬라이스 만큼 CPU를 이용하되, 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택한다. 

### 우선순위 스케줄링

우선순위 스케줄링은 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식이다. 이러한 방식은 근본적인 문제를 내포하고 있다. 

우선순위가 높은 프로세스를 먼저 처리하는 방식이기 때문에 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스로 인해 계속해서 실행이 연기될 수 있다. 이를 **“아사”** 현상이라고 한다. 

이를 방지하는 기법으로 **“에이징”** 기법이 있는데, 에이징은 오랫동안 대기한 프로세스의 우선 순위를 점차 높이는 방식이다. 

### 다단계 큐 스케줄링

다단계 큐 스케줄링은 우선순위 스케줄링의 발전된 형태로, 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식이다. 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있게 되면, 그 다음으로 우선순위가 높은 큐에 있는 프로세스를 처리한다. 

다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없기 때문에 우선순위가 낮은 프로세스의 작업이 계속해서 연기될 수 있다는 단점이 있다. 즉 앞에서 언급한 “아사” 현상이 발새할 수 있다. 

### 다단계 피드백 큐 스케줄링

다단계 피드백 큐 스케줄링은 다단계 큐 스케줄링과 비슷하게 동작하지만, 프로레스들이 큐 사이를 이동할 수 있다는 점에서 차이가 있다. 

다단계 피드백 큐 스케줄링에 새롭게 진입하는 프로세스는 먼저 가장 높은 우선순위 큐에 삽입된다. 만약 해당 큐에서 프로세스의 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행된다. 또, 해당 큐에서 실행이 끝나지 않은 프로세스는 그 다음 우선순위 큐에 삽입되어 실행된다. 

결국 오래 CPU를 사용해야 하는 프로세스의 우선순위는 점차 낮아지게 된다. 자연스럽게 비교적 CPU를 오래 사용해야하는 ‘CPU 집중 프로세스’들의 우선순위는 낮아지고, 비교적 CPU를 적게 사용해야하는 ‘입출력 집중 프로세스’들의 우선순위가 높은 큐에서 실행이 끝나게 된다. 

또한 아사 현상을 예방하기 위해 낮은 우선순위 큐에서 오래 기다리고 있는 프로세스들은 높은 우선순위 큐로 이동시키는 에이징 기법을 적용할 수 있다.

## 리눅스 CPU 스케줄링

리눅스에는 상황에 따라 다양한 스케줄링 알고리즘이 사용될 수 있다. 이는 리눅스 운영체제의 스케줄링 정책을 보면 알 수 있다. 

이들 중 일반적으로 가장 자주 언급되는 정책인 FIFO, RR, NORMAL 위주로 알아보겠다. 

SCHED_FIFO와 SCHED_RR은 RT스케줄러에 의해 이뤄지는 스케줄링이다. 이름 그대로 실시간성이 강조된 프로세스(실시간 프로세스)에 적용되는 스케줄링 정책이다. 

SCHED_NORMAL은 일반적인 프로세스에 적용되는 스케줄링 정책으로, SCHED_NORMAL 정책하에는 CFS라는 CPU 스케줄러에 의해 스케줄링이 이뤄진다. 

여기서 “CFS”는 이름처럼 프로세스에 대해 ‘완전히 공평한 CPU 시간 배분’을 지향하는 CPU 스케줄러를 말한다.